"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[8309],{85162:(e,t,n)=>{n.d(t,{Z:()=>o});var a=n(67294),i=n(86010);const s={tabItem:"tabItem_Ymn6"};function o(e){let{children:t,hidden:n,className:o}=e;return a.createElement("div",{role:"tabpanel",className:(0,i.Z)(s.tabItem,o),hidden:n},t)}},74866:(e,t,n)=>{n.d(t,{Z:()=>N});var a=n(87462),i=n(67294),s=n(86010),o=n(12466),r=n(16550),l=n(91980),p=n(67392),c=n(50012);function u(e){return function(e){return i.Children.map(e,(e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:i}}=e;return{value:t,label:n,attributes:a,default:i}}))}function d(e){const{values:t,children:n}=e;return(0,i.useMemo)((()=>{const e=t??u(n);return function(e){const t=(0,p.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function m(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function k(e){let{queryString:t=!1,groupId:n}=e;const a=(0,r.k6)(),s=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l._X)(s),(0,i.useCallback)((e=>{if(!s)return;const t=new URLSearchParams(a.location.search);t.set(s,e),a.replace({...a.location,search:t.toString()})}),[s,a])]}function h(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,s=d(e),[o,r]=(0,i.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:s}))),[l,p]=k({queryString:n,groupId:a}),[u,h]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,s]=(0,c.Nk)(n);return[a,(0,i.useCallback)((e=>{n&&s.set(e)}),[n,s])]}({groupId:a}),g=(()=>{const e=l??u;return m({value:e,tabValues:s})?e:null})();(0,i.useLayoutEffect)((()=>{g&&r(g)}),[g]);return{selectedValue:o,selectValue:(0,i.useCallback)((e=>{if(!m({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);r(e),p(e),h(e)}),[p,h,s]),tabValues:s}}var g=n(72389);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function y(e){let{className:t,block:n,selectedValue:r,selectValue:l,tabValues:p}=e;const c=[],{blockElementScrollPositionUntilNextRender:u}=(0,o.o5)(),d=e=>{const t=e.currentTarget,n=c.indexOf(t),a=p[n].value;a!==r&&(u(t),l(a))},m=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const n=c.indexOf(e.currentTarget)+1;t=c[n]??c[0];break}case"ArrowLeft":{const n=c.indexOf(e.currentTarget)-1;t=c[n]??c[c.length-1];break}}t?.focus()};return i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":n},t)},p.map((e=>{let{value:t,label:n,attributes:o}=e;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:r===t?0:-1,"aria-selected":r===t,key:t,ref:e=>c.push(e),onKeyDown:m,onClick:d},o,{className:(0,s.Z)("tabs__item",f.tabItem,o?.className,{"tabs__item--active":r===t})}),n??t)})))}function T(e){let{lazy:t,children:n,selectedValue:a}=e;const s=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=s.find((e=>e.props.value===a));return e?(0,i.cloneElement)(e,{className:"margin-top--md"}):null}return i.createElement("div",{className:"margin-top--md"},s.map(((e,t)=>(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function w(e){const t=h(e);return i.createElement("div",{className:(0,s.Z)("tabs-container",f.tabList)},i.createElement(y,(0,a.Z)({},e,t)),i.createElement(T,(0,a.Z)({},e,t)))}function N(e){const t=(0,g.Z)();return i.createElement(w,(0,a.Z)({key:String(t)},e))}},46300:(e,t,n)=>{n.d(t,{Z:()=>s});var a=n(67294),i=n(50012);function s(e){let{path:t}=e;const[n]=(0,i.Nk)("docusaurus.tab.js-ts"),s=t.lastIndexOf("{"),o=t.slice(s+1,t.length-1),[r,l]=o.split(","),p=t.slice(0,s);return a.createElement("code",null,p+("js"===n?r:l))}},87587:(e,t,n)=>{n.d(t,{Jp:()=>s,aH:()=>o});var a=n(67294);const i=e=>{let{color:t,children:n}=e;return a.createElement("span",{style:{border:`2px solid ${t}`,display:"inline-block",padding:"0.2em 0.4em",color:t,borderRadius:"0.4em",fontSize:"0.8em",lineHeight:"1",fontWeight:"bold"}},n)};function s(){return a.createElement(i,{color:"#0b62f5"},"internal")}function o(){return a.createElement(i,{color:"#f59e0b"},"required")}},48863:(e,t,n)=>{n.d(t,{A:()=>o,v:()=>r});var a=n(67294),i=n(50012),s=n(49875);function o(e){let{children:t}=e;const[n]=(0,i.Nk)("docusaurus.tab.js-ts");return"ts"===n&&a.createElement(s.Z,null,t)}function r(e){let{children:t}=e;const[n]=(0,i.Nk)("docusaurus.tab.js-ts");return"js"===n&&a.createElement(s.Z,null,t)}},9047:(e,t,n)=>{n.d(t,{ZP:()=>l});var a=n(87462),i=(n(67294),n(3905)),s=(n(46300),n(48863));const o={toc:[]},r="wrapper";function l(e){let{components:t,...n}=e;return(0,i.kt)(r,(0,a.Z)({},o,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Wasp uses ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/blitz-js/superjson"},"superjson")," under the hood.\nThis means you're not limited to only sending and receiving JSON payloads."),(0,i.kt)("p",{parentName:"admonition"},"You can send and receive any superjson-compatible payload (like Dates, Sets, Lists, circular references, etc.) and let Wasp handle the (de)serialization."),(0,i.kt)(s.A,{mdxType:"ShowForTs"},(0,i.kt)("p",{parentName:"admonition"},"As long as you're annotating your Queries with the correct automatically generated types, TypeScript ensures your payloads are valid (i.e., Wasp knows how to serialize and deserialize them)."))))}l.isMDXComponent=!0},42566:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>k,contentTitle:()=>d,default:()=>y,frontMatter:()=>u,metadata:()=>m,toc:()=>h});var a=n(87462),i=(n(67294),n(3905)),s=n(46300),o=n(85162),r=n(74866),l=n(87587),p=n(48863),c=n(9047);const u={title:"Actions"},d=void 0,m={unversionedId:"data-model/operations/actions",id:"version-0.11.8/data-model/operations/actions",title:"Actions",description:"We'll explain what Actions are and how to use them. If you're looking for a detailed API specification, skip ahead to the API Reference.",source:"@site/versioned_docs/version-0.11.8/data-model/operations/actions.md",sourceDirName:"data-model/operations",slug:"/data-model/operations/actions",permalink:"/docs/0.11.8/data-model/operations/actions",draft:!1,editUrl:"https://github.com/wasp-lang/wasp/edit/release/web/versioned_docs/version-0.11.8/data-model/operations/actions.md",tags:[],version:"0.11.8",frontMatter:{title:"Actions"},sidebar:"docs",previous:{title:"Queries",permalink:"/docs/0.11.8/data-model/operations/queries"},next:{title:"Automatic CRUD",permalink:"/docs/0.11.8/data-model/crud"}},k={},h=[{value:"Working with Actions",id:"working-with-actions",level:2},{value:"Declaring Actions",id:"declaring-actions",level:3},{value:"Implementing Actions in Node",id:"implementing-actions-in-node",level:3},{value:"Using Actions",id:"using-actions",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Using Entities in Actions",id:"using-entities-in-actions",level:3},{value:"Prisma Error Helpers",id:"prisma-error-helpers",level:3},{value:"Cache Invalidation",id:"cache-invalidation",level:2},{value:"Differences Between Queries and Actions",id:"differences-between-queries-and-actions",level:2},{value:"API Reference",id:"api-reference",level:2},{value:"Declaring Actions in Wasp",id:"declaring-actions-in-wasp",level:3},{value:"Example",id:"example",level:4},{value:"Implementing Actions",id:"implementing-actions",level:3},{value:"Example",id:"example-1",level:4},{value:"The <code>useAction</code> Hook and Optimistic Updates",id:"the-useaction-hook-and-optimistic-updates",level:3},{value:"Advanced usage",id:"advanced-usage",level:4}],g={toc:h},f="wrapper";function y(e){let{components:t,...n}=e;return(0,i.kt)(f,(0,a.Z)({},g,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"We'll explain what Actions are and how to use them. If you're looking for a detailed API specification, skip ahead to the ",(0,i.kt)("a",{parentName:"p",href:"#api-reference"},"API Reference"),"."),(0,i.kt)("p",null,"Actions are quite similar to ",(0,i.kt)("a",{parentName:"p",href:"/docs/0.11.8/data-model/operations/queries"},"Queries"),", but with a key distinction: Actions are designed to modify and add data, while Queries are solely for reading data. Examples of Actions include adding a comment to a blog post, liking a video, or updating a product's price."),(0,i.kt)("p",null,"Actions and Queries work together to keep data caches up-to-date."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Actions are almost identical to Queries in terms of their API.\nTherefore, if you're already familiar with Queries, you might find reading the entire guide repetitive."),(0,i.kt)("p",{parentName:"admonition"},"We instead recommend skipping ahead and only reading ",(0,i.kt)("a",{parentName:"p",href:"#differences-between-queries-and-actions"},"the differences between Queries and Actions"),", and consulting the ",(0,i.kt)("a",{parentName:"p",href:"#api-reference"},"API Reference")," as needed.")),(0,i.kt)("h2",{id:"working-with-actions"},"Working with Actions"),(0,i.kt)("p",null,"Actions are declared in Wasp and implemented in NodeJS. Wasp runs Actions within the server's context, but it also generates code that allows you to call them from anywhere in your code (either client or server) using the same interface."),(0,i.kt)("p",null,"This means you don't have to worry about building an HTTP API for the Action, managing server-side request handling, or even dealing with client-side response handling and caching.\nInstead, just focus on developing the business logic inside your Action, and let Wasp handle the rest!"),(0,i.kt)("p",null,"To create an Action, you need to:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Declare the Action in Wasp using the ",(0,i.kt)("inlineCode",{parentName:"li"},"action")," declaration."),(0,i.kt)("li",{parentName:"ol"},"Implement the Action's NodeJS functionality.")),(0,i.kt)("p",null,"Once these two steps are completed, you can use the Action from anywhere in your code."),(0,i.kt)("h3",{id:"declaring-actions"},"Declaring Actions"),(0,i.kt)("p",null,"To create an Action in Wasp, we begin with an ",(0,i.kt)("inlineCode",{parentName:"p"},"action")," declaration. Let's declare two Actions - one for creating a task, and another for marking tasks as done:"),(0,i.kt)(r.Z,{groupId:"js-ts",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-wasp",metastring:'title="main.wasp"',title:'"main.wasp"'},'// ...\n\naction createTask {\n  fn: import { createTask } from "@server/actions.js"\n}\n\naction markTaskAsDone {\n  fn: import { markTaskAsDone } from "@server/actions.js"\n}\n\n'))),(0,i.kt)(o.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-wasp",metastring:'title="main.wasp"',title:'"main.wasp"'},'// ...\n\naction createTask {\n  fn: import { createTask } from "@server/actions.js"\n}\n\naction markTaskAsDone {\n  fn: import { markTaskAsDone } from "@server/actions.js"\n}\n')),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"Even though you are using TypeScript and plan to implement this Action in ",(0,i.kt)("inlineCode",{parentName:"p"},"src/server/actions.ts"),", you still need to import it using a ",(0,i.kt)("inlineCode",{parentName:"p"},".js")," extension. Wasp internally uses ",(0,i.kt)("inlineCode",{parentName:"p"},"esnext")," module resolution, which requires importing all files with a ",(0,i.kt)("inlineCode",{parentName:"p"},".js")," extension. This is only needed when importing ",(0,i.kt)("inlineCode",{parentName:"p"},"@server")," files."),(0,i.kt)("p",{parentName:"admonition"},"Read more about ES modules in TypeScript ",(0,i.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/docs/handbook/esm-node.html"},"here"),". If you're interested in the discussion and the reasoning behind this, read about it ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/microsoft/TypeScript/issues/33588"},"in this GitHub issue"),".")))),(0,i.kt)("small",null,(0,i.kt)("p",null,"If you want to know about all supported options for the ",(0,i.kt)("inlineCode",{parentName:"p"},"action")," declaration, take a look at the ",(0,i.kt)("a",{parentName:"p",href:"#api-reference"},"API Reference"),".")),(0,i.kt)("p",null,"The names of Wasp Actions and their implementations don't necessarily have to match. However, to avoid confusion, we'll keep them the same."),(0,i.kt)(c.ZP,{mdxType:"SuperjsonNote"}),(0,i.kt)("p",null,"After declaring a Wasp Action, two important things happen:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Wasp ",(0,i.kt)("strong",{parentName:"p"},"generates a server-side NodeJS function")," that shares its name with the Action.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Wasp ",(0,i.kt)("strong",{parentName:"p"},"generates a client-side JavaScript function")," that shares its name with the Action (e.g., ",(0,i.kt)("inlineCode",{parentName:"p"},"markTaskAsDone"),").\nThis function takes a single optional argument - an object containing any serializable data you wish to use inside the Action.\nWasp will send this object over the network and pass it into the Action's implementation as its first positional argument (more on this when we look at the implementations).\nSuch an abstraction works thanks to an HTTP API route handler Wasp generates on the server, which calls the Action's NodeJS implementation under the hood."))),(0,i.kt)("p",null,"Generating these two functions ensures a uniform calling interface across the entire app (both client and server)."),(0,i.kt)("h3",{id:"implementing-actions-in-node"},"Implementing Actions in Node"),(0,i.kt)("p",null,"Now that we've declared the Action, what remains is to implement it. We've instructed Wasp to look for the Actions' implementations in the file ",(0,i.kt)(s.Z,{path:"src/server/actions.{js,ts}",mdxType:"FileExtSwitcher"}),", so that's where we should export them from."),(0,i.kt)("p",null,"Here's how you might implement the previously declared Actions ",(0,i.kt)("inlineCode",{parentName:"p"},"createTask")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"markTaskAsDone"),":"),(0,i.kt)(r.Z,{groupId:"js-ts",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/server/actions.js"',title:'"src/server/actions.js"'},"// our \"database\"\nlet nextId = 4\nconst tasks = [\n  { id: 1, description: 'Buy some eggs', isDone: true },\n  { id: 2, description: 'Make an omelette', isDone: false },\n  { id: 3, description: 'Eat breakfast', isDone: false },\n]\n\n// You don't need to use the arguments if you don't need them\nexport const createTask = (args) => {\n  const newTask = {\n    id: nextId,\n    isDone: false,\n    description: args.description,\n  }\n  nextId += 1\n  tasks.push(newTask)\n  return newTask\n}\n\n// The 'args' object is something sent by the caller (most often from the client)\nexport const markTaskAsDone = (args) => {\n  const task = tasks.find((task) => task.id === args.id)\n  if (!task) {\n    // We'll show how to properly handle such errors later\n    return\n  }\n  task.isDone = true\n}\n")),(0,i.kt)(c.ZP,{mdxType:"SuperjsonNote"})),(0,i.kt)(o.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/server/actions.ts"',title:'"src/server/actions.ts"'},"import { CreateTask, MarkTaskAsDone } from '@wasp/actions/types'\n\ntype Task = {\n  id: number\n  description: string\n  isDone: boolean\n}\n\n// our \"database\"\nlet nextId = 4\nconst tasks = [\n  { id: 1, description: 'Buy some eggs', isDone: true },\n  { id: 2, description: 'Make an omelette', isDone: false },\n  { id: 3, description: 'Eat breakfast', isDone: false },\n]\n\n// You don't need to use the arguments if you don't need them\nexport const createTask: CreateTask<Pick<Task, 'description'>, Task> = (\n  args\n) => {\n  const newTask = {\n    id: nextId,\n    isDone: false,\n    description: args.description,\n  }\n  nextId += 1\n  tasks.push(newTask)\n  return newTask\n}\n\n// The 'args' object is something sent by the caller (most often from the client)\nexport const markTaskAsDone: MarkTaskAsDone<Pick<Task, 'id'>, void> = (\n  args\n) => {\n  const task = tasks.find((task) => task.id === args.id)\n  if (!task) {\n    // We'll show how to properly handle such errors later\n    return\n  }\n  task.isDone = true\n}\n")),(0,i.kt)("p",null,"Wasp automatically generates the types ",(0,i.kt)("inlineCode",{parentName:"p"},"CreateTask")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"MarkTaskAsDone")," based on the declarations in your Wasp file:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CreateTask")," is a generic type that Wasp automatically generated based on the Action declaration for ",(0,i.kt)("inlineCode",{parentName:"li"},"createTask"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"MarkTaskAsDone")," is a generic type that Wasp automatically generated based on the Action declaration for ",(0,i.kt)("inlineCode",{parentName:"li"},"markTaskAsDone"),".")),(0,i.kt)("p",null,"You can use these types to specify the Action's input and output types."),(0,i.kt)("p",null,"The Action ",(0,i.kt)("inlineCode",{parentName:"p"},"createTask")," expects to get an object of type ",(0,i.kt)("inlineCode",{parentName:"p"},"{ description: string }")," and returns the newly created task (an object of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Task"),")."),(0,i.kt)("p",null,"The Action ",(0,i.kt)("inlineCode",{parentName:"p"},"markTaskAsDone"),", expects an object of type ",(0,i.kt)("inlineCode",{parentName:"p"},"{ id: number }")," and doesn't return anything (i.e., its return type is ",(0,i.kt)("inlineCode",{parentName:"p"},"void"),")."),(0,i.kt)("p",null,"We've derived most of the payload types from the type ",(0,i.kt)("inlineCode",{parentName:"p"},"Task"),"."),(0,i.kt)("p",null,"Annotating the Actions is optional, but highly recommended. Doing so enables ",(0,i.kt)("strong",{parentName:"p"},"full-stack type safety"),". We'll see what this means when calling the Action from the client."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Wasp uses ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/blitz-js/superjson"},"superjson")," under the hood. In other words, you don't need to limit yourself to only sending and receiving JSON payloads."),(0,i.kt)("p",{parentName:"admonition"},"Send and receive any superjson-compatible payload (e.g., Dates, Sets, Lists, circular references, etc.) and let Wasp take care of the (de)serialization."),(0,i.kt)("p",{parentName:"admonition"},"As long as you're annotating your Actions with correct automatically generated types, TypeScript ensures your payloads are valid (i.e., that Wasp knows how to serialize and deserialize them).")))),(0,i.kt)("small",null,(0,i.kt)("p",null,"For a detailed explanation of the Action definition API (i.e., arguments and return values), check the ",(0,i.kt)("a",{parentName:"p",href:"#api-reference"},"API Reference"),".")),(0,i.kt)("h3",{id:"using-actions"},"Using Actions"),(0,i.kt)("p",null,"To use an Action, you can import it from ",(0,i.kt)("inlineCode",{parentName:"p"},"@wasp")," and call it directly. As mentioned, the usage doesn't change depending on whether you're on the server or the client:"),(0,i.kt)(r.Z,{groupId:"js-ts",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"import createTask from '@wasp/actions/createTask.js'\nimport markTasAsDone from '@wasp/actions/markTasAsDone.js'\n\n// ...\n\nconst newTask = await createTask({ description: 'Learn TypeScript' })\nawait markTasAsDone({ id: 1 })\n"))),(0,i.kt)(o.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import createTask from '@wasp/actions/createTask.js'\nimport markTasAsDone from '@wasp/actions/markTasAsDone.js'\n\n// TypeScript automatically infers the return values and type-checks\n// the payloads.\nconst newTask = await createTask({ description: 'Keep learning TypeScript' })\nawait markTasAsDone({ id: 1 })\n")))),(0,i.kt)("p",null,"When using Actions on the client, you'll most likely want to use them inside a component:"),(0,i.kt)(r.Z,{groupId:"js-ts",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"{4,25} title=src/client/pages/Task.jsx","{4,25}":!0,title:"src/client/pages/Task.jsx"},"import React from 'react'\nimport { useQuery } from '@wasp/queries'\nimport getTask from '@wasp/queries/getTask'\nimport markTaskAsDone from '@wasp/actions/markTaskAsDone'\n\nexport const TaskPage = ({ id }) => {\n  const { data: task } = useQuery(getTask, { id })\n\n  if (!task) {\n    return <h1>\"Loading\"</h1>\n  }\n\n  const { description, isDone } = task\n  return (\n    <div>\n      <p>\n        <strong>Description: </strong>\n        {description}\n      </p>\n      <p>\n        <strong>Is done: </strong>\n        {isDone ? 'Yes' : 'No'}\n      </p>\n      {isDone || (\n        <button onClick={() => markTaskAsDone({ id })}>Mark as done.</button>\n      )}\n    </div>\n  )\n}\n"))),(0,i.kt)(o.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"{4,25} title=src/client/pages/Task.tsx","{4,25}":!0,title:"src/client/pages/Task.tsx"},"import React from 'react'\nimport { useQuery } from '@wasp/queries'\nimport getTask from '@wasp/queries/getTask'\nimport markTaskAsDone from '@wasp/actions/markTaskAsDone'\n\nexport const TaskPage = ({ id }: { id: number }) => {\n  const { data: task } = useQuery(getTask, { id })\n\n  if (!task) {\n    return <h1>\"Loading\"</h1>\n  }\n\n  const { description, isDone } = task\n  return (\n    <div>\n      <p>\n        <strong>Description: </strong>\n        {description}\n      </p>\n      <p>\n        <strong>Is done: </strong>\n        {isDone ? 'Yes' : 'No'}\n      </p>\n      {isDone || (\n        <button onClick={() => markTaskAsDone({ id })}>Mark as done.</button>\n      )}\n    </div>\n  )\n}\n")))),(0,i.kt)("p",null,"Since Actions don't require reactivity, they are safe to use inside components without a hook. Still, Wasp provides comes with the ",(0,i.kt)("inlineCode",{parentName:"p"},"useAction")," hook you can use to enhance actions. Read all about it in the ",(0,i.kt)("a",{parentName:"p",href:"#api-reference"},"API Reference"),"."),(0,i.kt)("h3",{id:"error-handling"},"Error Handling"),(0,i.kt)("p",null,"For security reasons, all exceptions thrown in the Action's NodeJS implementation are sent to the client as responses with the HTTP status code ",(0,i.kt)("inlineCode",{parentName:"p"},"500"),", with all other details removed.\nHiding error details by default helps against accidentally leaking possibly sensitive information over the network."),(0,i.kt)("p",null,"If you do want to pass additional error information to the client, you can construct and throw an appropriate ",(0,i.kt)("inlineCode",{parentName:"p"},"HttpError")," in your implementation:"),(0,i.kt)(r.Z,{groupId:"js-ts",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:"title=src/server/actions.js",title:"src/server/actions.js"},"import HttpError from '@wasp/core/HttpError.js'\n\nexport const createTask = async (args, context) => {\n  throw new HttpError(\n    403, // status code\n    \"You can't do this!\", // message\n    { foo: 'bar' } // data\n  )\n}\n"))),(0,i.kt)(o.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=src/server/actions.ts",title:"src/server/actions.ts"},"import { CreateTask } from '@wasp/actions/types'\nimport HttpError from '@wasp/core/HttpError.js'\n\nexport const createTask: CreateTask = async (args, context) => {\n  throw new HttpError(\n    403, // status code\n    \"You can't do this!\", // message\n    { foo: 'bar' } // data\n  )\n}\n")))),(0,i.kt)("h3",{id:"using-entities-in-actions"},"Using Entities in Actions"),(0,i.kt)("p",null,"In most cases, resources used in Actions will be ",(0,i.kt)("a",{parentName:"p",href:"/docs/0.11.8/data-model/entities"},"Entities"),".\nTo use an Entity in your Action, add it to the ",(0,i.kt)("inlineCode",{parentName:"p"},"action")," declaration in Wasp:"),(0,i.kt)(r.Z,{groupId:"js-ts",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-wasp",metastring:'{4,9} title="main.wasp"',"{4,9}":!0,title:'"main.wasp"'},'\naction createTask {\n  fn: import { createTask } from "@server/actions.js",\n  entities: [Task]\n}\n\naction markTaskAsDone {\n  fn: import { markTaskAsDone } from "@server/actions.js",\n  entities: [Task]\n}\n'))),(0,i.kt)(o.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-wasp",metastring:'{4,9} title="main.wasp"',"{4,9}":!0,title:'"main.wasp"'},'\naction createTask {\n  fn: import { createTask } from "@server/actions.js",\n  entities: [Task]\n}\n\naction markTaskAsDone {\n  fn: import { markTaskAsDone } from "@server/actions.js",\n  entities: [Task]\n}\n')))),(0,i.kt)("p",null,"Wasp will inject the specified Entity into the Action's ",(0,i.kt)("inlineCode",{parentName:"p"},"context")," argument, giving you access to the Entity's Prisma API.\nWasp invalidates frontend Query caches by looking at the Entities used by each Action/Query. Read more about Wasp's smart cache invalidation ",(0,i.kt)("a",{parentName:"p",href:"#cache-invalidation"},"here"),"."),(0,i.kt)(r.Z,{groupId:"js-ts",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/server/actions.js"',title:'"src/server/actions.js"'},"// The 'args' object is the payload sent by the caller (most often from the client)\nexport const createTask = async (args, context) => {\n  const newTask = await context.entities.Task.create({\n    data: {\n      description: args.description,\n      isDone: false,\n    },\n  })\n  return newTask\n}\n\nexport const markTaskAsDone = async (args, context) => {\n  await context.entities.Task.update({\n    where: { id: args.id },\n    data: { isDone: true },\n  })\n}\n"))),(0,i.kt)(o.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/server/actions.ts"',title:'"src/server/actions.ts"'},"import { CreateTask, MarkTaskAsDone } from '@wasp/actions/types'\nimport { Task } from '@wasp/entities'\n\n// The 'args' object is the payload sent by the caller (most often from the client)\nexport const createTask: CreateTask<Pick<Task, 'description'>, Task> = async (\n  args,\n  context\n) => {\n  const newTask = await context.entities.Task.create({\n    data: {\n      description: args.description,\n      isDone: false,\n    },\n  })\n  return newTask\n}\n\nexport const markTaskAsDone: MarkTaskAsDone<Pick<Task, 'id'>, void> = async (\n  args,\n  context\n) => {\n  await context.entities.Task.update({\n    where: { id: args.id },\n    data: { isDone: true },\n  })\n}\n")),(0,i.kt)("p",null,"Again, annotating the Actions is optional, but greatly improves ",(0,i.kt)("strong",{parentName:"p"},"full-stack type safety"),"."))),(0,i.kt)("p",null,"The object ",(0,i.kt)("inlineCode",{parentName:"p"},"context.entities.Task")," exposes ",(0,i.kt)("inlineCode",{parentName:"p"},"prisma.task")," from ",(0,i.kt)("a",{parentName:"p",href:"https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/crud"},"Prisma's CRUD API"),"."),(0,i.kt)("h3",{id:"prisma-error-helpers"},"Prisma Error Helpers"),(0,i.kt)("p",null,"In your Operations, you may wish to handle general Prisma errors with HTTP-friendly responses."),(0,i.kt)("p",null,"Wasp exposes two helper functions, ",(0,i.kt)("inlineCode",{parentName:"p"},"isPrismaError"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"prismaErrorToHttpError"),", for this purpose. As of now, we convert two specific Prisma errors (which we will continue to expand), with the rest being ",(0,i.kt)("inlineCode",{parentName:"p"},"500"),". See the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/wasp-lang/wasp/blob/main/waspc/e2e-test/test-outputs/waspMigrate-golden/waspMigrate/.wasp/out/server/src/utils.js"},"source here"),"."),(0,i.kt)("p",null,"Here's how you can import and use them:"),(0,i.kt)(r.Z,{groupId:"js-ts",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'import { isPrismaError, prismaErrorToHttpError } from "@wasp/utils.js";\n\n// ...\n\ntry {\n  await context.entities.Task.create({...})\n} catch (e) {\n  if (isPrismaError(e)) {\n    throw prismaErrorToHttpError(e)\n  } else {\n    throw e\n  }\n}\n'))),(0,i.kt)(o.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'import { isPrismaError, prismaErrorToHttpError } from "@wasp/utils.js";\n\n// ...\n\ntry {\n  await context.entities.Task.create({...})\n} catch (e) {\n  if (isPrismaError(e)) {\n    throw prismaErrorToHttpError(e)\n  } else {\n    throw e\n  }\n}\n')))),(0,i.kt)("h2",{id:"cache-invalidation"},"Cache Invalidation"),(0,i.kt)("p",null,"One of the trickiest parts of managing a web app's state is making sure the data returned by the Queries is up to date.\nSince Wasp uses ",(0,i.kt)("em",{parentName:"p"},"react-query")," for Query management, we must make sure to invalidate Queries (more specifically, their cached results managed by ",(0,i.kt)("em",{parentName:"p"},"react-query"),") whenever they become stale."),(0,i.kt)("p",null,"It's possible to invalidate the caches manually through several mechanisms ",(0,i.kt)("em",{parentName:"p"},"react-query")," provides (e.g., refetch, direct invalidation).\nHowever, since manual cache invalidation quickly becomes complex and error-prone, Wasp offers a faster and a more effective solution to get you started: ",(0,i.kt)("strong",{parentName:"p"},"automatic Entity-based Query cache invalidation"),".\nBecause Actions can (and most often do) modify the state while Queries read it, Wasp invalidates a Query's cache whenever an Action that uses the same Entity is executed."),(0,i.kt)("p",null,"For example, if the Action ",(0,i.kt)("inlineCode",{parentName:"p"},"createTask")," and Query ",(0,i.kt)("inlineCode",{parentName:"p"},"getTasks")," both use the Entity ",(0,i.kt)("inlineCode",{parentName:"p"},"Task"),", executing ",(0,i.kt)("inlineCode",{parentName:"p"},"createTask")," may cause the cached result of ",(0,i.kt)("inlineCode",{parentName:"p"},"getTasks")," to become outdated. In response, Wasp will invalidate it, causing ",(0,i.kt)("inlineCode",{parentName:"p"},"getTasks")," to refetch data from the server and update it."),(0,i.kt)("p",null,'In practice, this means that Wasp keeps the Queries "fresh" without requiring you to think about cache invalidation.'),(0,i.kt)("p",null,"On the other hand, this kind of automatic cache invalidation can become wasteful (some updates might not be necessary) and will only work for Entities. If that's an issue, you can use the mechanisms provided by ",(0,i.kt)("em",{parentName:"p"},"react-query")," for now, and expect more direct support in Wasp for handling those use cases in a nice, elegant way."),(0,i.kt)("p",null,"If you wish to optimistically set cache values after performing an Action, you can do so using ",(0,i.kt)("a",{parentName:"p",href:"https://stackoverflow.com/a/33009713"},"optimistic updates"),". Configure them using Wasp's ",(0,i.kt)("a",{parentName:"p",href:"#the-useaction-hook-and-optimistic-updates"},"useAction hook"),". This is currently the only manual cache invalidation mechanism Wasps supports natively. For everything else, you can always rely on ",(0,i.kt)("em",{parentName:"p"},"react-query"),"."),(0,i.kt)("h2",{id:"differences-between-queries-and-actions"},"Differences Between Queries and Actions"),(0,i.kt)("p",null,"Actions and Queries are two closely related concepts in Wasp. They might seem to perform similar tasks, but Wasp treats them differently, and each concept represents a different thing."),(0,i.kt)("p",null,"Here are the key differences between Queries and Actions:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Actions can (and often should) modify the server's state, while Queries are only permitted to read it. Wasp relies on you adhering to this convention when performing cache invalidations, so it's crucial to follow it."),(0,i.kt)("li",{parentName:"ol"},"Actions don't need to be reactive, so you can call them directly. However, Wasp does provide a ",(0,i.kt)("a",{parentName:"li",href:"#the-useaction-hook-and-optimistic-updates"},(0,i.kt)("inlineCode",{parentName:"a"},"useAction")," React hook")," for adding extra behavior to the Action (like optimistic updates)."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"action")," declarations in Wasp are mostly identical to ",(0,i.kt)("inlineCode",{parentName:"li"},"query")," declarations. The only difference lies in the declaration's name.")),(0,i.kt)("h2",{id:"api-reference"},"API Reference"),(0,i.kt)("h3",{id:"declaring-actions-in-wasp"},"Declaring Actions in Wasp"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"action")," declaration supports the following fields:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"fn: ServerImport")," ",(0,i.kt)(l.aH,{mdxType:"Required"})),(0,i.kt)("p",{parentName:"li"},"The import statement of the Action's NodeJs implementation.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"entities: [Entity]")),(0,i.kt)("p",{parentName:"li"},"A list of entities you wish to use inside your Action.\nFor instructions on using Entities in Actions, take a look at ",(0,i.kt)("a",{parentName:"p",href:"#using-entities-in-actions"},"the guide"),"."))),(0,i.kt)("h4",{id:"example"},"Example"),(0,i.kt)(r.Z,{groupId:"js-ts",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,i.kt)("p",null,"Declaring the Action:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-wasp"},'query createFoo {\n    fn: import { createFoo } from "@server/actions.js"\n    entities: [Foo]\n}\n')),(0,i.kt)("p",null,"Enables you to import and use it anywhere in your code (on the server or the client):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import createFoo from '@wasp/actions/createFoo'\n"))),(0,i.kt)(o.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,i.kt)("p",null,"Declaring the Action:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-wasp"},'query createFoo {\n    fn: import { createFoo } from "@server/actions.js"\n    entities: [Foo]\n}\n')),(0,i.kt)("p",null,"And also creates a type you can import on the server:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import createFoo from '@wasp/actions'\n")),(0,i.kt)("p",null,"As well as the following type import on the server:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import type { CreateFoo } from '@wasp/actions/types'\n")))),(0,i.kt)("h3",{id:"implementing-actions"},"Implementing Actions"),(0,i.kt)("p",null,"The Action's implementation is a NodeJS function that takes two arguments (it can be an ",(0,i.kt)("inlineCode",{parentName:"p"},"async")," function if you need to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"await")," keyword).\nSince both arguments are positional, you can name the parameters however you want, but we'll stick with ",(0,i.kt)("inlineCode",{parentName:"p"},"args")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"context"),":"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"args")," (type depends on the Action)"),(0,i.kt)("p",{parentName:"li"},"An object containing the data ",(0,i.kt)("strong",{parentName:"p"},"passed in when calling the Action")," (e.g., filtering conditions).\nCheck ",(0,i.kt)("a",{parentName:"p",href:"#using-actions"},"the usage examples")," to see how to pass this object to the Action.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"context")," (type depends on the Action)"),(0,i.kt)("p",{parentName:"li"},"An additional context object ",(0,i.kt)("strong",{parentName:"p"},"passed into the Action by Wasp"),". This object contains user session information, as well as information about entities. Check the ",(0,i.kt)("a",{parentName:"p",href:"#using-entities-in-actions"},"section about using entities in Actions")," to see how to use the entities field on the ",(0,i.kt)("inlineCode",{parentName:"p"},"context")," object, or the ",(0,i.kt)("a",{parentName:"p",href:"../../auth/overview#using-the-contextuser-object"},"auth section")," to see how to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"user")," object."))),(0,i.kt)(p.A,{mdxType:"ShowForTs"},(0,i.kt)("p",null,"Afer you ",(0,i.kt)("a",{parentName:"p",href:"#declaring-actions"},"declare the Action"),", Wasp generates a generic type you can use when defining its implementation.\nFor the Action declared as ",(0,i.kt)("inlineCode",{parentName:"p"},"createSomething"),", the generated type is called ",(0,i.kt)("inlineCode",{parentName:"p"},"CreateSomething"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { CreateSomething } from '@wasp/actions/types'\n")),(0,i.kt)("p",null,"It expects two (optional) type arguments:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"Input")),(0,i.kt)("p",{parentName:"li"},"The type of the ",(0,i.kt)("inlineCode",{parentName:"p"},"args")," object (i.e., the Action's input payload). The default value is ",(0,i.kt)("inlineCode",{parentName:"p"},"never"),".")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"Output")),(0,i.kt)("p",{parentName:"li"},"The type of the Action's return value (i.e., the Action's output payload). The default value is ",(0,i.kt)("inlineCode",{parentName:"p"},"unknown"),"."))),(0,i.kt)("p",null,"The defaults were chosen to make the type signature as permissive as possible. If don't want your Action to take/return anything, use ",(0,i.kt)("inlineCode",{parentName:"p"},"void")," as a type argument.")),(0,i.kt)("h4",{id:"example-1"},"Example"),(0,i.kt)(r.Z,{groupId:"js-ts",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,i.kt)("p",null,"The following Action:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-wasp"},'action createFoo {\n    fn: import { createFoo } from "@server/actions.js"\n    entities: [Foo]\n}\n')),(0,i.kt)("p",null,"Expects to find a named export ",(0,i.kt)("inlineCode",{parentName:"p"},"createfoo")," from the file ",(0,i.kt)("inlineCode",{parentName:"p"},"src/server/actions.js")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:"title=actions.js",title:"actions.js"},"export const createFoo = (args, context) => {\n  // implementation\n}\n"))),(0,i.kt)(o.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-wasp"},'action createFoo {\n    fn: import { createFoo } from "@server/actions.js"\n    entities: [Foo]\n}\n')),(0,i.kt)("p",null,"Expects to find a named export ",(0,i.kt)("inlineCode",{parentName:"p"},"createfoo")," from the file ",(0,i.kt)("inlineCode",{parentName:"p"},"src/server/actions.js")),(0,i.kt)("p",null,"You can use the generated type ",(0,i.kt)("inlineCode",{parentName:"p"},"CreateFoo")," and specify the Action's inputs and outputs using its type arguments."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=actions.ts",title:"actions.ts"},'import { CreateFoo } from "@wasp/actions/types";\n\ntype Foo = // ...\n\nexport const createFoo: CreateFoo<{ bar: string }, Foo> = (args, context) => {\n  // implementation\n};\n')),(0,i.kt)("p",null,"In this case, the Action expects to receive an object with a ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," field of type ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," (this is the type of ",(0,i.kt)("inlineCode",{parentName:"p"},"args"),"), and return a value of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Foo")," (this must match the type of the Action's return value)."))),(0,i.kt)("h3",{id:"the-useaction-hook-and-optimistic-updates"},"The ",(0,i.kt)("inlineCode",{parentName:"h3"},"useAction")," Hook and Optimistic Updates"),(0,i.kt)("p",null,"Make sure you understand how ",(0,i.kt)("a",{parentName:"p",href:"/docs/0.11.8/data-model/operations/queries"},"Queries")," and ",(0,i.kt)("a",{parentName:"p",href:"#cache-invalidation"},"Cache Invalidation")," work before reading this chapter."),(0,i.kt)("p",null,"When using Actions in components, you can enhance them with the help of the ",(0,i.kt)("inlineCode",{parentName:"p"},"useAction")," hook. This hook comes bundled with Wasp, and is used for decorating Wasp Actions.\nIn other words, the hook returns a function whose API matches the original Action while also doing something extra under the hood (depending on how you configure it)."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"useAction")," hook accepts two arguments:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"actionFn")," ",(0,i.kt)(l.aH,{mdxType:"Required"})),(0,i.kt)("p",{parentName:"li"},"The Wasp Action (i.e., the client-side Action function generated by Wasp based on a Action declaration) you wish to enhance.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"actionOptions")),(0,i.kt)("p",{parentName:"li"},"An object configuring the extra features you want to add to the given Action. While this argument is technically optional, there is no point in using the ",(0,i.kt)("inlineCode",{parentName:"p"},"useAction")," hook without providing it (it would be the same as using the Action directly). The Action options object supports the following fields:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"optimisticUpdates")),(0,i.kt)("p",{parentName:"li"},"An array of objects where each object defines an ",(0,i.kt)("a",{parentName:"p",href:"https://stackoverflow.com/a/33009713"},"optimistic update")," to perform on the Query cache. To define an optimistic update, you must specify the following properties:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getQuerySpecifier")," ",(0,i.kt)(l.aH,{mdxType:"Required"}))),(0,i.kt)("p",{parentName:"li"},"A function returning the Query specifier (i.e., a value used to address the Query you want to update). A Query specifier is an array specifying the query function and arguments. For example, to optimistically update the Query used with ",(0,i.kt)("inlineCode",{parentName:"p"},"useQuery(fetchFilteredTasks, {isDone: true }]"),", your ",(0,i.kt)("inlineCode",{parentName:"p"},"getQuerySpecifier")," function would have to return the array ",(0,i.kt)("inlineCode",{parentName:"p"},"[fetchFilteredTasks, { isDone: true}]"),". Wasp will forward the argument you pass into the decorated Action to this function (i.e., you can use the properties of the added/changed item to address the Query)."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"updateQuery")," ",(0,i.kt)(l.aH,{mdxType:"Required"}))),(0,i.kt)("p",{parentName:"li"},"The function used to perform the optimistic update. It should return the desired state of the cache. Wasp will call it with the following arguments:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"item")," - The argument you pass into the decorated Action."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"oldData")," - The currently cached value for the Query identified by the specifier.")))))),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"updateQuery")," function must be a pure function. It must return the desired cache value identified by the ",(0,i.kt)("inlineCode",{parentName:"p"},"getQuerySpecifier")," function and ",(0,i.kt)("em",{parentName:"p"},"must not")," perform any side effects."),(0,i.kt)("p",{parentName:"admonition"},"Also, make sure you only update the Query caches affected by your Action causing the optimistic update (Wasp cannot yet verify this)."),(0,i.kt)("p",{parentName:"admonition"},"Finally, your implementation of the ",(0,i.kt)("inlineCode",{parentName:"p"},"updateQuery")," function should work correctly regardless of the state of ",(0,i.kt)("inlineCode",{parentName:"p"},"oldData")," (e.g., don't rely on array positioning). If you need to do something else during your optimistic update, you can directly use ",(0,i.kt)("em",{parentName:"p"},"react-query"),"'s lower-level API (read more about it ",(0,i.kt)("a",{parentName:"p",href:"#advanced-usage"},"here"),").")),(0,i.kt)("p",null,"Here's an example showing how to configure the Action ",(0,i.kt)("inlineCode",{parentName:"p"},"markTaskAsDone")," that toggles a task's ",(0,i.kt)("inlineCode",{parentName:"p"},"isDone")," status to perform an optimistic update:"),(0,i.kt)(r.Z,{groupId:"js-ts",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"{3,9,10,11,12,13,14,15,16,34} title=src/client/pages/Task.jsx","{3,9,10,11,12,13,14,15,16,34}":!0,title:"src/client/pages/Task.jsx"},"import React from 'react'\nimport { useQuery } from '@wasp/queries'\nimport { useAction } from '@wasp/actions'\nimport getTask from '@wasp/queries/getTask'\nimport markTaskAsDone from '@wasp/actions/markTaskAsDone'\n\nconst TaskPage = ({ id }) => {\n  const { data: task } = useQuery(getTask, { id })\n  const markTaskAsDoneOptimistically = useAction(markTaskAsDone, {\n    optimisticUpdates: [\n      {\n        getQuerySpecifier: ({ id }) => [getTask, { id }],\n        updateQuery: (_payload, oldData) => ({ ...oldData, isDone: true }),\n      },\n    ],\n  })\n\n  if (!task) {\n    return <h1>\"Loading\"</h1>\n  }\n\n  const { description, isDone } = task\n  return (\n    <div>\n      <p>\n        <strong>Description: </strong>\n        {description}\n      </p>\n      <p>\n        <strong>Is done: </strong>\n        {isDone ? 'Yes' : 'No'}\n      </p>\n      {isDone || (\n        <button onClick={() => markTaskAsDoneOptimistically({ id })}>\n          Mark as done.\n        </button>\n      )}\n    </div>\n  )\n}\n\nexport default TaskPage\n"))),(0,i.kt)(o.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"{2,4,8,12,13,14,15,16,17,18,19,37} title=src/client/pages/Task.js","{2,4,8,12,13,14,15,16,17,18,19,37}":!0,title:"src/client/pages/Task.js"},'import React from "react";\nimport { useQuery } from "@wasp/queries";\nimport { useAction, OptimisticUpdateDefinition } from "@wasp/actions";\nimport getTask from "@wasp/queries/getTask";\nimport markTaskAsDone from "@wasp/actions/markTaskAsDone";\n\ntype TaskPayload = Pick<Task, "id">;\n\nconst TaskPage = ({ id }: { id: number }) => {\n  const { data: task } = useQuery(getTask, { id });\n  const markTaskAsDoneOptimistically = useAction(markTaskAsDone, {\n    optimisticUpdates: [\n      {\n        getQuerySpecifier: ({ id }) => [getTask, { id }],\n        updateQuery: (_payload, oldData) => ({ ...oldData, isDone: true }),\n      } as OptimisticUpdateDefinition<TaskPayload, Task>,\n    ],\n  });\n\n  if (!task) {\n    return <h1>"Loading"</h1>;\n  }\n\n  const { description, isDone } = task;\n  return (\n    <div>\n      <p>\n        <strong>Description: </strong>\n        {description}\n      </p>\n      <p>\n        <strong>Is done: </strong>\n        {isDone ? "Yes" : "No"}\n      </p>\n      {isDone || (\n        <button onClick={() => markTaskAsDoneOptimistically({ id })}>\n          Mark as done.\n        </button>\n      )}\n    </div>\n  );\n};\n\nexport default TaskPage;\n')))),(0,i.kt)("h4",{id:"advanced-usage"},"Advanced usage"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"useAction")," hook currently only supports specifying optimistic updates. You can expect more features in future versions of Wasp."),(0,i.kt)("p",null,"Wasp's optimistic update API is deliberately small and focuses exclusively on updating Query caches (as that's the most common use case). You might need an API that offers more options or a higher level of control. If that's the case, instead of using Wasp's ",(0,i.kt)("inlineCode",{parentName:"p"},"useAction")," hook, you can use ",(0,i.kt)("em",{parentName:"p"},"react-query"),"'s ",(0,i.kt)("inlineCode",{parentName:"p"},"useMutation")," hook and directly work with ",(0,i.kt)("a",{parentName:"p",href:"https://tanstack.com/query/v4/docs/guides/optimistic-updates?from=reactQueryV3&original=https://react-query-v3.tanstack.com/guides/optimistic-updates"},"their low-level API"),"."),(0,i.kt)("p",null,"If you decide to use ",(0,i.kt)("em",{parentName:"p"},"react-query"),"'s API directly, you will need access to Query cache key. Wasp internally uses this key but abstracts it from the programmer. Still, you can easily obtain it by accessing the ",(0,i.kt)("inlineCode",{parentName:"p"},"queryCacheKey")," property on any Query:"),(0,i.kt)(r.Z,{groupId:"js-ts",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import getTasks from '@wasp/queries/getTasks'\n\nconst queryKey = getTasks.queryCacheKey\n"))),(0,i.kt)(o.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import getTasks from '@wasp/queries/getTasks'\n\nconst queryKey = getTasks.queryCacheKey\n")))))}y.isMDXComponent=!0}}]);