"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[9454],{85162:(e,t,a)=>{a.d(t,{Z:()=>i});var n=a(67294),s=a(86010);const r={tabItem:"tabItem_Ymn6"};function i(e){let{children:t,hidden:a,className:i}=e;return n.createElement("div",{role:"tabpanel",className:(0,s.Z)(r.tabItem,i),hidden:a},t)}},74866:(e,t,a)=>{a.d(t,{Z:()=>y});var n=a(87462),s=a(67294),r=a(86010),i=a(12466),o=a(16550),l=a(91980),c=a(67392),u=a(50012);function p(e){return function(e){return s.Children.map(e,(e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:a,attributes:n,default:s}}=e;return{value:t,label:a,attributes:n,default:s}}))}function d(e){const{values:t,children:a}=e;return(0,s.useMemo)((()=>{const e=t??p(a);return function(e){const t=(0,c.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function m(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function k(e){let{queryString:t=!1,groupId:a}=e;const n=(0,o.k6)(),r=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:t,groupId:a});return[(0,l._X)(r),(0,s.useCallback)((e=>{if(!r)return;const t=new URLSearchParams(n.location.search);t.set(r,e),n.replace({...n.location,search:t.toString()})}),[r,n])]}function h(e){const{defaultValue:t,queryString:a=!1,groupId:n}=e,r=d(e),[i,o]=(0,s.useState)((()=>function(e){let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=a.find((e=>e.default))??a[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:r}))),[l,c]=k({queryString:a,groupId:n}),[p,h]=function(e){let{groupId:t}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(t),[n,r]=(0,u.Nk)(a);return[n,(0,s.useCallback)((e=>{a&&r.set(e)}),[a,r])]}({groupId:n}),g=(()=>{const e=l??p;return m({value:e,tabValues:r})?e:null})();(0,s.useLayoutEffect)((()=>{g&&o(g)}),[g]);return{selectedValue:i,selectValue:(0,s.useCallback)((e=>{if(!m({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);o(e),c(e),h(e)}),[c,h,r]),tabValues:r}}var g=a(72389);const T={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function v(e){let{className:t,block:a,selectedValue:o,selectValue:l,tabValues:c}=e;const u=[],{blockElementScrollPositionUntilNextRender:p}=(0,i.o5)(),d=e=>{const t=e.currentTarget,a=u.indexOf(t),n=c[a].value;n!==o&&(p(t),l(n))},m=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const a=u.indexOf(e.currentTarget)+1;t=u[a]??u[0];break}case"ArrowLeft":{const a=u.indexOf(e.currentTarget)-1;t=u[a]??u[u.length-1];break}}t?.focus()};return s.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":a},t)},c.map((e=>{let{value:t,label:a,attributes:i}=e;return s.createElement("li",(0,n.Z)({role:"tab",tabIndex:o===t?0:-1,"aria-selected":o===t,key:t,ref:e=>u.push(e),onKeyDown:m,onClick:d},i,{className:(0,r.Z)("tabs__item",T.tabItem,i?.className,{"tabs__item--active":o===t})}),a??t)})))}function b(e){let{lazy:t,children:a,selectedValue:n}=e;const r=(Array.isArray(a)?a:[a]).filter(Boolean);if(t){const e=r.find((e=>e.props.value===n));return e?(0,s.cloneElement)(e,{className:"margin-top--md"}):null}return s.createElement("div",{className:"margin-top--md"},r.map(((e,t)=>(0,s.cloneElement)(e,{key:t,hidden:e.props.value!==n}))))}function f(e){const t=h(e);return s.createElement("div",{className:(0,r.Z)("tabs-container",T.tabList)},s.createElement(v,(0,n.Z)({},e,t)),s.createElement(b,(0,n.Z)({},e,t)))}function y(e){const t=(0,g.Z)();return s.createElement(f,(0,n.Z)({key:String(t)},e))}},57850:(e,t,a)=>{a.d(t,{Z:()=>r});var n=a(67294),s=a(65471);function r(e){const{children:t,title:a}=e;return n.createElement(s.Z,null,n.createElement("summary",{mdxType:"summary"},a),t)}},46300:(e,t,a)=>{a.d(t,{Z:()=>r});var n=a(67294),s=a(50012);function r(e){let{path:t}=e;const[a]=(0,s.Nk)("docusaurus.tab.js-ts"),r=t.lastIndexOf("{"),i=t.slice(r+1,t.length-1),[o,l]=i.split(","),c=t.slice(0,r);return n.createElement("code",null,c+("js"===a?o:l))}},48863:(e,t,a)=>{a.d(t,{A:()=>i,v:()=>o});var n=a(67294),s=a(50012),r=a(49875);function i(e){let{children:t}=e;const[a]=(0,s.Nk)("docusaurus.tab.js-ts");return"ts"===a&&n.createElement(r.Z,null,t)}function o(e){let{children:t}=e;const[a]=(0,s.Nk)("docusaurus.tab.js-ts");return"js"===a&&n.createElement(r.Z,null,t)}},71184:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>k,contentTitle:()=>d,default:()=>v,frontMatter:()=>p,metadata:()=>m,toc:()=>h});var n=a(87462),s=(a(67294),a(3905)),r=a(46300),i=a(85162),o=a(74866),l=a(44996),c=a(48863),u=a(57850);const p={title:"6. Modifying Data"},d=void 0,m={unversionedId:"tutorial/actions",id:"version-0.11.8/tutorial/actions",title:"6. Modifying Data",description:"In the previous section, we learned about using queries to fetch data and only briefly mentioned that actions can be used to update the database. Let's learn more about actions so we can add and update tasks in the database.",source:"@site/versioned_docs/version-0.11.8/tutorial/06-actions.md",sourceDirName:"tutorial",slug:"/tutorial/actions",permalink:"/docs/0.11.8/tutorial/actions",draft:!1,editUrl:"https://github.com/wasp-lang/wasp/edit/release/web/versioned_docs/version-0.11.8/tutorial/06-actions.md",tags:[],version:"0.11.8",sidebarPosition:6,frontMatter:{title:"6. Modifying Data"},sidebar:"docs",previous:{title:"5. Querying the Database",permalink:"/docs/0.11.8/tutorial/queries"},next:{title:"7. Adding Authentication",permalink:"/docs/0.11.8/tutorial/auth"}},k={},h=[{value:"Creating a New Action",id:"creating-a-new-action",level:2},{value:"Declaring an Action",id:"declaring-an-action",level:3},{value:"Implementing an Action",id:"implementing-an-action",level:3},{value:"Invoking the Action on the Client",id:"invoking-the-action-on-the-client",level:2},{value:"A Second Action",id:"a-second-action",level:2}],g={toc:h},T="wrapper";function v(e){let{components:t,...a}=e;return(0,s.kt)(T,(0,n.Z)({},g,a,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"In the previous section, we learned about using queries to fetch data and only briefly mentioned that actions can be used to update the database. Let's learn more about actions so we can add and update tasks in the database."),(0,s.kt)("p",null,"We have to create:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"A Wasp action that creates a new task."),(0,s.kt)("li",{parentName:"ol"},"A React form that calls that action when the user creates a task.")),(0,s.kt)("h2",{id:"creating-a-new-action"},"Creating a New Action"),(0,s.kt)("p",null,"Creating an action is very similar to creating a query."),(0,s.kt)("h3",{id:"declaring-an-action"},"Declaring an Action"),(0,s.kt)("p",null,"We must first declare the action in ",(0,s.kt)("inlineCode",{parentName:"p"},"main.wasp"),":"),(0,s.kt)(o.Z,{groupId:"js-ts",mdxType:"Tabs"},(0,s.kt)(i.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-wasp",metastring:'title="main.wasp"',title:'"main.wasp"'},'// ...\n\naction createTask {\n  fn: import { createTask } from "@server/actions.js",\n  entities: [Task]\n}\n'))),(0,s.kt)(i.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-wasp",metastring:'title="main.wasp"',title:'"main.wasp"'},'// ...\n\naction createTask {\n  fn: import { createTask } from "@server/actions.js",\n  entities: [Task]\n}\n')))),(0,s.kt)("h3",{id:"implementing-an-action"},"Implementing an Action"),(0,s.kt)("p",null,"Let's now define a ",(0,s.kt)(c.v,{mdxType:"ShowForJs"},"JavaScript"),(0,s.kt)(c.A,{mdxType:"ShowForTs"},"TypeScript")," function for our ",(0,s.kt)("inlineCode",{parentName:"p"},"createTask")," action:"),(0,s.kt)(o.Z,{groupId:"js-ts",mdxType:"Tabs"},(0,s.kt)(i.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/server/actions.js"',title:'"src/server/actions.js"'},"export const createTask = async (args, context) => {\n  return context.entities.Task.create({\n    data: { description: args.description },\n  })\n}\n"))),(0,s.kt)(i.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/server/actions.ts"',title:'"src/server/actions.ts"'},"import { Task } from '@wasp/entities'\nimport { CreateTask } from '@wasp/actions/types'\n\ntype CreateTaskPayload = Pick<Task, 'description'>\n\nexport const createTask: CreateTask<CreateTaskPayload, Task> = async (\n  args,\n  context\n) => {\n  return context.entities.Task.create({\n    data: { description: args.description },\n  })\n}\n")),(0,s.kt)("p",null,"Once again, we've annotated the action with the generated ",(0,s.kt)("inlineCode",{parentName:"p"},"CreateTask")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"Task")," types generated by Wasp. Just like with queries, defining the types on the implemention makes them available on the frontend, giving us ",(0,s.kt)("strong",{parentName:"p"},"full-stack type safety"),"."))),(0,s.kt)("admonition",{type:"tip"},(0,s.kt)("p",{parentName:"admonition"},"We put the function in a new file ",(0,s.kt)(r.Z,{path:"src/server/actions.{js,ts}",mdxType:"FileExtSwitcher"}),", but we could have put it anywhere we wanted! There are no limitations here, as long as the declaration in the Wasp file imports it correctly and the file is located within ",(0,s.kt)("inlineCode",{parentName:"p"},"src/server"),".")),(0,s.kt)("h2",{id:"invoking-the-action-on-the-client"},"Invoking the Action on the Client"),(0,s.kt)("p",null,"First, let's define a form that the user can create new tasks with."),(0,s.kt)(o.Z,{groupId:"js-ts",mdxType:"Tabs"},(0,s.kt)(i.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx",metastring:'{2,7-26} title="src/client/MainPage.jsx"',"{2,7-26}":!0,title:'"src/client/MainPage.jsx"'},'import getTasks from \'@wasp/queries/getTasks\'\nimport createTask from \'@wasp/actions/createTask\'\nimport { useQuery } from \'@wasp/queries\'\n\n// ...\n\nconst NewTaskForm = () => {\n  const handleSubmit = async (event) => {\n    event.preventDefault()\n    try {\n      const target = event.target\n      const description = target.description.value\n      target.reset()\n      await createTask({ description })\n    } catch (err) {\n      window.alert(\'Error: \' + err.message)\n    }\n  }\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input name="description" type="text" defaultValue="" />\n      <input type="submit" value="Create task" />\n    </form>\n  )\n}\n'))),(0,s.kt)(i.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'{1,3,9-28} title="src/client/MainPage.tsx"',"{1,3,9-28}":!0,title:'"src/client/MainPage.tsx"'},"import { FormEvent } from 'react'\nimport getTasks from '@wasp/queries/getTasks'\nimport createTask from '@wasp/actions/createTask'\nimport { useQuery } from '@wasp/queries'\nimport { Task } from '@wasp/entities'\n\n// ...\n\nconst NewTaskForm = () => {\n  const handleSubmit = async (event: FormEvent<HTMLFormElement>) => {\n    event.preventDefault()\n    try {\n      const target = event.target as HTMLFormElement\n      const description = target.description.value\n      target.reset()\n      await createTask({ description })\n    } catch (err: any) {\n      window.alert('Error: ' + err.message)\n    }\n  }\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input name=\"description\" type=\"text\" defaultValue=\"\" />\n      <input type=\"submit\" value=\"Create task\" />\n    </form>\n  )\n}\n")))),(0,s.kt)("p",null,"Unlike queries, you call actions directly (i.e., without wrapping it with a hook) because we don't need reactivity. The rest is just regular React code."),(0,s.kt)(c.A,{mdxType:"ShowForTs"},(0,s.kt)("p",null,"Finally, because we've previously annotated the Action's backend implementation with the correct type, Wasp knows that the ",(0,s.kt)("inlineCode",{parentName:"p"},"createTask")," action expects a value of type ",(0,s.kt)("inlineCode",{parentName:"p"},"{ description: string }")," (try changing the argument and reading the error message). Wasp also knows that a call to the ",(0,s.kt)("inlineCode",{parentName:"p"},"createTask")," action returns a ",(0,s.kt)("inlineCode",{parentName:"p"},"Task")," but are not using it in this example.")),(0,s.kt)("p",null,"Now, we just need to add this form to the page component:"),(0,s.kt)(o.Z,{groupId:"js-ts",mdxType:"Tabs"},(0,s.kt)(i.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx",metastring:'{10} title="src/client/MainPage.tsx"',"{10}":!0,title:'"src/client/MainPage.tsx"'},"import getTasks from '@wasp/queries/getTasks'\nimport createTask from '@wasp/actions/createTask'\nimport { useQuery } from '@wasp/queries'\n\nconst MainPage = () => {\n  const { data: tasks, isLoading, error } = useQuery(getTasks)\n\n  return (\n    <div>\n      <NewTaskForm />\n\n      {tasks && <TasksList tasks={tasks} />}\n\n      {isLoading && 'Loading...'}\n      {error && 'Error: ' + error}\n    </div>\n  )\n}\n"))),(0,s.kt)(i.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'{12} title="src/client/MainPage.tsx"',"{12}":!0,title:'"src/client/MainPage.tsx"'},"import { FormEvent } from 'react'\nimport getTasks from '@wasp/queries/getTasks'\nimport createTask from '@wasp/actions/createTask'\nimport { useQuery } from '@wasp/queries'\nimport { Task } from '@wasp/entities'\n\nconst MainPage = () => {\n  const { data: tasks, isLoading, error } = useQuery(getTasks)\n\n  return (\n    <div>\n      <NewTaskForm />\n\n      {tasks && <TasksList tasks={tasks} />}\n\n      {isLoading && 'Loading...'}\n      {error && 'Error: ' + error}\n    </div>\n  )\n}\n")))),(0,s.kt)("p",null,"And now we have a form that creates new tasks."),(0,s.kt)("p",null,'Try creating a "Build a Todo App in Wasp" task and see it appear in the list below. The task is created on the server and saved in the database.'),(0,s.kt)("p",null,"Try refreshing the page or opening it in another browser, you'll see the tasks are still there!"),(0,s.kt)("img",{alt:"Todo App - creating new task",src:(0,l.Z)("img/todo-app-new-task.png"),style:{border:"1px solid black"}}),(0,s.kt)("br",null),(0,s.kt)("br",null),(0,s.kt)("admonition",{title:"Automatic Query Invalidation",type:"note"},(0,s.kt)("p",{parentName:"admonition"},"When you create a new task, the list of tasks is automatically updated to display the new task, even though we have not written any code that would do that! These automatic updates are handled by code that Wasp generates."),(0,s.kt)("p",{parentName:"admonition"},"When you declared the ",(0,s.kt)("inlineCode",{parentName:"p"},"getTasks")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"createTask")," operations, you specified that they both use the ",(0,s.kt)("inlineCode",{parentName:"p"},"Task")," entity. So when ",(0,s.kt)("inlineCode",{parentName:"p"},"createTask")," is called, Wasp knows that the data ",(0,s.kt)("inlineCode",{parentName:"p"},"getTasks")," fetches may have changed and automatically updates it in the background. This means that ",(0,s.kt)("strong",{parentName:"p"},"out of the box, Wasp will make sure that all your queries are kept in-sync with changes made by any actions"),"."),(0,s.kt)("p",{parentName:"admonition"},"This behavior is convenient as a default but can cause poor performance in large apps. While there is no mechanism for overriding this behavior yet, it is something that we plan to include in Wasp in the future. This feature is tracked ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/wasp-lang/wasp/issues/63"},"here"),".")),(0,s.kt)("h2",{id:"a-second-action"},"A Second Action"),(0,s.kt)("p",null,"Our Todo app isn't finished if you can't mark a task as done! We'll create a new action to update a task's status and call it from React whenever a task's checkbox is toggled."),(0,s.kt)("p",null,"Since we've already created one task together, try to create this one yourself. It should be an action named ",(0,s.kt)("inlineCode",{parentName:"p"},"updateTask")," that takes a task ",(0,s.kt)("inlineCode",{parentName:"p"},"id")," and an ",(0,s.kt)("inlineCode",{parentName:"p"},"isDone")," in its arguments. You can check our implementation below."),(0,s.kt)(u.Z,{title:"Solution",mdxType:"Collapse"},(0,s.kt)("p",null,"The action declaration:"),(0,s.kt)(o.Z,{groupId:"js-ts",mdxType:"Tabs"},(0,s.kt)(i.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-wasp",metastring:'title="main.wasp"',title:'"main.wasp"'},'// ...\n\naction updateTask {\n  fn: import { updateTask } from "@server/actions.js",\n  entities: [Task]\n}\n'))),(0,s.kt)(i.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-wasp",metastring:'title="main.wasp"',title:'"main.wasp"'},'// ...\n\naction updateTask {\n  fn: import { updateTask } from "@server/actions.js",\n  entities: [Task]\n}\n')))),(0,s.kt)("p",null,"The implementation on the server:"),(0,s.kt)(o.Z,{groupId:"js-ts",mdxType:"Tabs"},(0,s.kt)(i.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/server/actions.js"',title:'"src/server/actions.js"'},"// ...\n\nexport const updateTask = async ({ id, isDone }, context) => {\n  return context.entities.Task.update({\n    where: { id },\n    data: {\n      isDone: isDone,\n    },\n  })\n}\n"))),(0,s.kt)(i.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/server/actions.ts"',title:'"src/server/actions.ts"'},"// highlight-next-line\nimport { CreateTask, UpdateTask } from '@wasp/actions/types'\n\n// ...\n\ntype UpdateTaskPayload = Pick<Task, 'id' | 'isDone'>\n\nexport const updateTask: UpdateTask<UpdateTaskPayload, Task> = async (\n  { id, isDone },\n  context\n) => {\n  return context.entities.Task.update({\n    where: { id },\n    data: {\n      isDone: isDone,\n    },\n  })\n}\n"))))),(0,s.kt)("p",null,"Now, we can call ",(0,s.kt)("inlineCode",{parentName:"p"},"updateTask")," from the React component:"),(0,s.kt)(o.Z,{groupId:"js-ts",mdxType:"Tabs"},(0,s.kt)(i.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx",metastring:'{2,7-16,24} title="src/client/MainPage.jsx"',"{2,7-16,24}":!0,title:'"src/client/MainPage.jsx"'},"// ...\nimport updateTask from '@wasp/actions/updateTask'\n\n// ...\n\nconst Task = ({ task }) => {\n  const handleIsDoneChange = async (event) => {\n    try {\n      await updateTask({\n        id: task.id,\n        isDone: event.target.checked,\n      })\n    } catch (error) {\n      window.alert('Error while updating task: ' + error.message)\n    }\n  }\n\n  return (\n    <div>\n      <input\n        type=\"checkbox\"\n        id={String(task.id)}\n        checked={task.isDone}\n        onChange={handleIsDoneChange}\n      />\n      {task.description}\n    </div>\n  )\n}\n// ...\n"))),(0,s.kt)(i.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx",metastring:'{2,4,9-18,26} title="src/client/MainPage.tsx"',"{2,4,9-18,26}":!0,title:'"src/client/MainPage.tsx"'},"// ...\nimport { FormEvent, ChangeEvent } from 'react'\n// ...\nimport updateTask from '@wasp/actions/updateTask'\n\n// ...\n\nconst Task = ({ task }: { task: Task }) => {\n  const handleIsDoneChange = async (event: ChangeEvent<HTMLInputElement>) => {\n    try {\n      await updateTask({\n        id: task.id,\n        isDone: event.target.checked,\n      })\n    } catch (error: any) {\n      window.alert('Error while updating task: ' + error.message)\n    }\n  }\n\n  return (\n    <div>\n      <input\n        type=\"checkbox\"\n        id={String(task.id)}\n        checked={task.isDone}\n        onChange={handleIsDoneChange}\n      />\n      {task.description}\n    </div>\n  )\n}\n// ...\n")))),(0,s.kt)("p",null,"Awesome! Now we can check off this task \ud83d\ude43 Let's add one more interesting feature to our app."))}v.isMDXComponent=!0}}]);