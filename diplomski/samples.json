[
    {
        "name": "arrays",
        "code": "// This sample demonstrates how to write functions that work with arrays.\n\nfunc square(x) = x * x\nfunc even(x) = x % 2 == 0\nfunc max(x, y) = x if x > y else y\n\n// Check task 1 in https://www.joelonsoftware.com/2005/12/29/test-yourself/\nfunc accumulate(combiner, nullValue, l) =\n    nullValue if isEmpty(l) else\n    combiner(head(l), accumulate(combiner, nullValue, tail(l)))\n\nfunc getSumOfSquares(l) =\n    accumulate((x, y) -> square(x) + y, 0, l)\n\nfunc reverse1(array) =\n    [] if isEmpty(array) else\n    let current = head(array);\n        rest = tail(array);\n    in [*reverse1(rest), current]\n\n// We can implement the same functionality using the built in-reduce function:\nfunc reverse2(array) =\n    reduce((acc, x) -> [x, *acc], [], array)\n\nfunc flatten1(array) =\n    [] if isEmpty(array) else\n    [*head(array), *flatten1(tail(array))]\n\n// Again, the same can be accomplished using reduce:\nfunc flatten2(array) =\n    reduce((acc, x) -> [*acc, *x], [], array)\n\nfunc quicksort(array) =\n    [] if isEmpty(array) else\n    let pivot = head(array);\n        rest = tail(array);\n        lowerHalf = rest |> filter(`< pivot`) |> quicksort;\n        higherHalf = rest |> filter(`>= pivot`) |> quicksort;\n    in [*lowerHalf, pivot, *higherHalf]\n\n// We can put multiple statements on the same line using semicolons:\nevens = [2,4,6]; odds = [1,3,5]\n\n// Join arrays using the concatenation operator...\nconcatArray = [0] ++ evens ++ [0] ++ odds ++ [0]\n\n// ...or using the spread syntax:\nspread = [0, *evens, 0, *odds, 0]\n\n// Strings are just character arrays:\nconcatString = \"One\" ++ \", \" ++ \"Two\"\n\nnumbers = [1, 3, 12, 4, 2, 11, 31, 7, 8]\nnested = [\n    [(1, \"One\"), (2, \"Two\"), (3, \"Three\")],\n    [(4, \"Four\"), (5, \"Five\"), (6, \"Six\")],\n]\n\nsorted = quicksort(numbers)\n\nreversed1 = reverse1(numbers)\nreversed2 = reverse2(numbers)\n\nflattened1 = flatten1(nested)\nflattened2 = flatten2(nested)\n\nsumOfSquares = getSumOfSquares(numbers)\nlargestEvenSquare = numbers\n    |> filter(even)\n    |> map(square)\n    |> reduce0(max)"
    },
    {
        "name": "bare",
        "code": "casio1 = 9 / 3 * (1 + 2)\ncasio2 = 9 / (3 * (1 + 2))\ncorrectAnswer = 1\n\nbare =\n    \"Tuzno\" if casio1 == correctAnswer else\n    \"Zagradu moras prvu rijesit\" if casio2 == correctAnswer else\n    \"\ud83d\udc40\ud83d\udc40\ud83d\udc40\ud83d\udc40\""
    },
    {
        "name": "church",
        "code": "// This sample shows how lambda calculus encodes booleans and pairs.\n\n// Implementation of Church booleans (booleans in lambda calculus)\n// Read more: https://en.wikipedia.org/wiki/Church_encoding#Church_Booleans\nfunc true(x, y) = x\nfunc false(x, y) = y\n\n// Implementation of Church pairs (tuples in lambda calculus)\n// Read more: https://en.wikipedia.org/wiki/Church_encoding#Church_pairs\nfunc pair(x, y, z) = z(x, y)\n\n// We have to prefix function names with underscores to avoid clashes with builtin functions \"first\"\n// and \"second\"\nfunc _first(p) = p(true)\nfunc _second(p) = p(false)\n\nmovie1 = pair(12, \"Monkeys\") // creates pair (12, \"Monkeys\")\nmovie2 = pair(96, \"Hours\")\nmovie3 = pair(True, \"Grit\")\nmovie4 = pair(\"Fast\", 5)\n\ntwelve = _first(movie1)\nhours = _second(movie2)\n_true = _first(movie3)\nfive = _second(movie4)"
    },
    {
        "name": "discrete",
        "code": "// This sample contains examples related to discrete mathematics. Bigint would be a better type than\n// Number for these purposes. However, the language doesn't yet support ad-hoc polymorphism (i.e.,\n// we can't use arithmetic operators with Bigints), so we have to use Numbers.\n\n// This is an implementation of the Euclidean algorithm\n// (https://en.wikipedia.org/wiki/Euclidean_algorithm):\nfunc gcd(x, y) =\n    x if y == 0 else\n    gcd(y, x % y)\n\nfunc lcd(x, y) = x * y / gcd(x, y)\n\ngcd_5_7 = gcd(5, 7)\ngcd_18_12 = gcd(18, 12)\ngcd_63_78 = gcd(63, 78)\ngcd_14288_21432 = gcd(14288, 21432)\n\nlcd_17_11 = lcd(17, 11)\nlcd_12_18 = lcd(12, 18)\nlcd_63_78 = lcd(63, 78)\nlcd_14288_21432 = lcd(14288, 21432)\n\n// The functions below determine whether the given year is a leap year:\nfunc divisibleBy(n, k) = n % k == 0\n\nfunc isLeapYear(year) =\n    divisibleBy(year, 400)\n    || divisibleBy(year, 4) && !divisibleBy(year, 25)\n\nleap_1700 = isLeapYear(1700)\nleap_2000 = isLeapYear(2000)\nleap_2012 = isLeapYear(2012)\nleap_2016 = isLeapYear(2016)\nleap_2017 = isLeapYear(2017)\n\n// We can also create number ranges:\nfunc stepRange(start, end, step) =\n    [start] if start >= end else\n    [start, *stepRange(start + step, end, step)]\n\nfunc range(start, end) = stepRange(start, end, 1)\n\nfiveTenFifteen = stepRange(5, 15, 5)\nmultiplesOfThree = stepRange(0, 100, 3)\nrange1to10 = range(1, 10)\n\n// Combinatorics:\nfunc fact(n) =\n    1 if n <= 0 else\n    n * fact(n - 1)\n\nfunc combinations(n, k) =\n    fact(n) / (fact(n - k) * fact(k))\n\n_1c0 = combinations(1, 0)\n_5c3 = combinations(5, 3)\n_12c4 = combinations(12, 4)\n\nfunc pascalTriangle(level) =\n    let func pascalRow(n) = range(0, n) |> map(combinations(n))\n    in range(0, level) |> map(pascalRow)\n\npascal7 = pascalTriangle(7)"
    },
    {
        "name": "empty",
        "code": "// Choose \"Edit\" mode and try writing whatever you want..."
    },
    {
        "name": "geometry",
        "code": "// Examples involving geometry:\n\npi = 3.14159265359\n\nfunc calcArea(r) = let r2 = r * r in\n    r2 * pi\n\nfunc calcCircumference(r) =\n    2 * r * pi\n\narea = calcArea(2 / sqrt(pi))                     // should be 4\ncircumference = calcCircumference(1 / (0.4 * pi)) // should be 5\n\ntriangleA = [\n    (0, 3),\n    (7, 4),\n    (4, 0),\n]\n\ntriangleB = [\n    (1, 1),\n    (3, 1),\n    (2, 3),\n]\n\nfunc euclidDistance(p1, p2) =\n    let x1 = first(p1);\n        y1 = second(p1);\n        x2 = first(p2);\n        y2 = second(p2);\n        func square(x) = x * x;\n    in sqrt(square(x1 - x2) + square(y1 - y2))\n\nfunc furthestFrom(point, points) =\n    let distanceOf = euclidDistance(point);\n        func maxByDistance(a, b) = a if distanceOf(a) > distanceOf(b) else b;\n    in points |> reduce0(maxByDistance)\n\nfunc addPoints(p1, p2) =\n    let a = first(p1) + first(p2);\n        b = second(p1) + second(p2);\n    in (a, b)\n\nfunc mapPair(f, pair) =\n    let a = (f . first)(pair);\n        b = (f . second)(pair);\n    in (a, b)\n\nfunc centroidOf(points) =\n    let func middle(x) = x / length(points)\n    in points |> reduce0(addPoints) |> mapPair(middle)\n\ncentroidA = centroidOf(triangleA)\ncentroidB = centroidOf(triangleB)\n\n// The furthest point from center in both triangles\nfurthestFromCenter = [*triangleA, *triangleB] |> furthestFrom((0, 0))"
    },
    {
        "name": "intro",
        "code": "// This tutorial introduces a high-level, general-purpose, statically typed, garbage collected,\n// purely functional programming language with type inference. It is mostly based on ML, Haskell,\n// and JavaScript.\n//\n// The language features a type system proven to be mathematically sound and decidable, which is a\n// lot less common than one might think: https://typing-is-hard.ch/. All types are inferred and\n// checked automatically using the Hindley-Milner type system. The programmer doesn't need to\n// provide any type annotations or type hints. Read more about Hindley-Milner here:\n// https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system\n//\n// Select code to view, edit, and compile from a set of samples (including this one) using\n// the dropdown menu in the top left.\n//\n// Use the buttons \"Read\" and \"Edit\" in the middle for toggling between reading and editing\n// modes.\n//\n// For information about variables' types (and values after execution), select the \"Symbol Table\"\n// tab in the top right. Use the \"Generated Code\" tab for inspecting the JS code produced by the\n// compiler.\n//\n// There are four primitive types in the language: Number, Bigint, Char, Bool. We can define\n// variables by assigning values to names. Their types are inferred automatically:\n\nnumber1 = 13     // inferred as type 'Number'\nnumber2 = 2.5e-1 // inferred as type 'Number'\n\ntrue = True      // inferred as type 'Bool'\n\n// All of these variables are inferred to be of type 'Char':\nchar1 = 'H'\nchar2 = 'e'\nchar3 = 'l'\nchar4 = 'l'\nchar5 = 'o'\n\n// We can define functions with function statements (this is the preferred way and the only way that\n// supports recursion)...\nfunc add(x, y) = x + y\n\n// ...or assigned function expressions (this is the quick-and-dirty way and should ideally be used\n// only for short anonymous inline functions)\nadd2 = (x, y) -> x + y\n\n// Aside from the fact that 'add2' couldn't be recursive if we wanted it to, the two above\n// functions are fully equivalent.\n\n// As mentioned in the introduction, the type inference algorithm is proven to be decidable, sound,\n// and complete. In other words, the compiler always successfully detects all type errors at\n// compile-time without requiring any type annotations.\n//\n// Uncomment the following lines to see the type checker at work:\n\n// error1 = add(1, True)         // Error: Passing `Bool` instead of `Number`\n// error2 = add(1, 2) == \"Marko\" // Error: Comparing 'Number' with 'String\n\n// All functions are curried (i.e., each function accepts only a single argument). A multi-argument\n// function is nothing more than a function that takes just a single argument (the first one) and\n// returns another function that takes the remaining arguments (in the same recursive manner). For\n// example, the following function is equivalent to 'add' and 'add2'.\n\nadd3 = (x) -> (y) -> x + y // lambda definitions are right-associative\n\n// In fact, all function calls of form 'f(a, b, c, ..., z)' should be interpreted as\n// 'f(a)(b)(c)...(z)'. These two statements are fully equivalent (take a look at the generated code\n// and see for yourself):\ntwoPlusThree1 = add(2, 3)\ntwoPlusThree2 = add(2)(3)\n\n// Curried functions enable trivial partial application. For example, the definition of 'next' below\n// does not produce a type error. It instead binds the first argument and returns a function of type\n// 'Number -> Number' ready to accept the second argument and execute the body. In other words,\n// 'next' is also a function.\nnext = add(1)\n\ntwo = next(1)\nfive = next(next(next(two)))\n\n// As in all other functional languages, functions are first-class entities\n// (https://en.wikipedia.org/wiki/First-class_function):\nfunc square(x) = x * x\nfunc negate(x) = !x\nfunc applyAndIncrement(f, x) = f(x) + 1\nthreeSquaredPlusOne = applyAndIncrement(square, 3)\n\n// The type inference algorithm always infers the most general possible type of an expression, thus\n// enabling parametric polymorphism (i.e., generics) out of the box. Take a look at this simple\n// function as an example:\nfunc apply(f, x) = f(x)\n\n// The inferred type of 'apply' is '(t1 -> t2) -> t1 -> t2', where 't1' and 't2' represent unbound\n// type variables. Type variables are replaced (instantiated) with a more specific type when we\n// apply the function. Possible instances of 'apply' include:\ninst1 = apply((x) -> x > 3, 5) // as '(Number -> Bool) -> Number -> Bool', returning 'Bool'\ninst2 = apply((x) -> x + 1, 6) // as '(Number -> Number) -> Number -> Number', returning 'Number'\ninst3 = apply(id)              // as '(t1 -> t1) -> t1 -> t1', partially bound, returning 't1 -> t1'\n\n// The inferred type of 'applyTwice' is '(t1 -> t1) -> t1 -> t1'. Applying 'f' to the result of 'f'\n// constrains its output type to its input type. In other words, 'f' can't have the type 't1 -> t2'.\n// It must have the type 't1 -> t1'. Otherwise, we couldn't reapply 'f' to its output.\nfunc applyTwice(f, x) = f(f(x))\n\n// As mentioned, a parametrically polymorphic function can take on different forms (instances),\n// as long as they satisfy its constraints:\nsixteen = applyTwice(square, 2)\nfalse   = applyTwice(negate, True)\n\n// When the constraints aren't satisfied, the compiler produces a type error (uncomment to see):\n\n// error3 = applyTwice(square, True)\n\n// Almost everything in the language is an expression and can be used in other expressions. For\n// example, there are no conditional statements, only conditional expressions. Conditional\n// expressions borrow their syntax and semantics from Python's ternary expression:\nfunc max(a, b) =\n    a if a > b else b\n\n// Both branches of a conditional expression must return the same type:\nfunc stepFunction(threshold, value) = 1 if value > threshold else 0   // this is OK\n// func stepFunction(threshold, value) = '1' if value > threshold else 0 // this is not OK\n\n// All expressions are space insensitive (i.e., we can format them arbitrarily, even make them span\n// multiple lines):\nshouldBe4 =\n    max(\n        1.5, 4\n    )\n\n// Conditionals and recursion open the door for writing more complex functions:\nfunc factorial(n) =\n    1 if n <= 0 else\n    n * factorial(n -1)\n\nfunc numberOfCombinations(n, k) =\n    factorial(n) / (factorial(n - k) * factorial(k))\n\n_5c2 = numberOfCombinations(5, 2)\n\n// The language also supports parametric types (i.e., polymorphic type constructors, containers)\n// such as arrays (homogenous with variable length) and tuples (heterogeneous, fixed-length up to 5):\narray1 = [1, 2, 3, 4, 5]\narray2 = ['M', 'a', 'r', 'k', 'o']\n\ntuple1 = (5, 'c')\ntuple2 = (1, True, '1')\n\n// Pairs (tuples of size 2) come with convenient built-in functions 'first' and 'second':\nletterInfo = ('c', 3)\nc          = first(letterInfo)\nthree      = second(letterInfo)\n\n\n// You can find more examples in sample \"tuples\".\n\n// We can concatenate arrays with the concatenation operator '++':\ncountTo8 = [1, 2, 3] ++ [4, 5] ++ [6, 7, 8]\n\n// Array literals also support the spread operator. Its semantics are based on JavaScript's ellipsis\n// ('...') operator, while its syntax is based on Python's star ('*') operator. We can mix spreads\n// with regular values:\noneTwo = [1, 2]\nfour = [4]\ncountTo8Alternative = [*oneTwo, 3, *four, 5, *[6, 7, 8]]  // same as 'countTo8'\n\n// Strings are just syntactic sugar for defining arrays of characters. For example, the\n// following expressions are fully equivalent:\nname1 = ['L', 'u', 'k', 'a']\nname2 = \"Luka\"\n\n// Everything we can do with arrays, we can do with Strings (they're just a special case):\nfullName = \"Josip\" ++ \" \" ++ \"Jela\u010di\u0107\"\n\n// Let's take a look at a few built-in array functions. If variable names aren't descriptive\n// enough, you can check the Symbol Table and examine their values:\nfirstElement                = head(countTo8)\narrayWithoutTheFirstElement = tail(countTo8)\nisArrayEmpty                = isEmpty(countTo8)\nhowLongIsTheArray           = length(countTo8)\n\n// After finishing this introduction, you can check the sample \"arrays\" for more array-related\n// examples.\n\n// Parametric types elevate parametric polymorphism to a higher level. They allow us to operate on\n// containers without worrying about wrapped types. For example, reversing an array is entirely\n// agnostic to the values inside. We can define a single function and use it to reverse arrays\n// of any type, as long as it's an array (check the type of 'reverse' in the symbol table):\nfunc reverse(array) =\n    [] if isEmpty(array) else\n    reverse(tail(array)) ++ [head(array)]\n\ncountdownFrom8 = reverse(countTo8)\ntheShinning = reverse(\"redrum\")\n\n// The only constraint we should have when flattening an array is that the array is nested (i.e.,\n// it's at least 2D, there's something to flatten). Everything else is arbitrary, including further\n// nesting. Let's define 'flatten' using the spread operator instead of concatenation:\nfunc flatten(array) =\n    [] if isEmpty(array) else\n    [*head(array), *flatten(tail(array))]\n\nflat1 = flatten([[1, 2], [3, 4]])\nflat2 = flatten([\"To\", \"ster\"])\nflat3 = flatten([[(1, \"One\"), (2, \"Two\")], [(3, \"Three\"), (4, \"Four\")]])\n\n// For another example of parametric polymorphism through type containers, let's look at a pair\n// flipping function. It works for all pairs, regardless of what's inside:\nfunc flip(tuple) = (second(tuple), first(tuple)) // try to guess the type\n\nmovie1 = flip((\"Grit\", True))\nmovie2 = flip((\"Angry Men\", 12))\nmovie3 = flip((8, \"The Hateful\"))\n\n// The last core part of the language is the \"let\" expression. Its syntax and semantics were\n// inspired by ML and Haskell. We can use it to define local constants:\nletExample1 = let x = 3 in x * x\n\n// We can define multiple constants within a single let expression by delimiting them with a\n// semicolon.\nfunc letExample2(x, y) =              // calculates f(x, y) = x * y / abs(x - y)\n    let\n        larger  = x if x >= y else y;\n        smaller = x if x < y else y;\n        product = x * y;\n    in\n        product / (larger - smaller)\n\n// As first-class values, functions can be passed around and manipulated in many ways. One\n// contrived example follows.\nfunc weird(x, f) =\n    (square if ((y) -> y > 3)(x) else let n = 4 in (y) -> f(y + n))(f(x))\n        if x < 0 else\n    weird(x - 1, f)\n// If you want to see more creative usages of functions, take a look at the sample \"lambda\"\n// (available in the dropdown menu).\n\n// We've now gone through all core language features. However, there are still several syntactic\n// constructs we have left to cover. The language also comes with a modest (but useful) standard\n// library, parts of which we've already seen.\n//\n// Adding to the already mentioned array manipulation functions ('head', 'tail', 'length',\n// 'isEmpty'), the language also includes the standard 'map', 'filter', and 'reduce' (i.e., fold).\n// These functions' semantics are mostly universal across all languages that feature them (e.g.,\n// JavaScript, Python, Haskell, Java). Our syntax is most similar to Python's:\nsquares1To8 = map(square, countTo8)\nevens1To8 = filter((x) -> x % 2 == 0, countTo8)\n\nsum1To8 = reduce((sum, x) -> sum + x, 0, countTo8)\nproduct1To8 = reduce((prod, x) -> prod * x, 1, countTo8)\n\n// We can easily generalize 'sum' and 'product' into reusable functions. Let's do it using the tacit\n// programming style (https://en.wikipedia.org/wiki/Tacit_programming):\nsum = reduce((sum, x) -> sum + x, 0)\nproduct = reduce((prod, x) -> prod * x, 1)\n\n// We can use 'reduce' to implement shorter alternatives to functions 'flatten' and 'reverse' from\n// earlier:\nfunc reverse2(array) =\n    reduce((rev, curr) -> [curr, *rev], [], array)\n\nfunc flatten2(array) =\n    reduce((flat, curr) -> [*flat, *curr], [], array)\n\n// These three built-in functions can be very expressive when chained together. For example, we\n// could use them to find the largest even square smaller than 50 in a number array:\nnumbers = [1, 2, 4, 11, 2, 4, 5, 7, 9, 10, 15, 13, 17, 18, 19, 6, 3]\n\nsquare1 = reduce(max, 0, filter((x) -> x < 50, map(square, filter((x) -> x % 2 == 0, numbers))))\n\n// As you've probably noticed, our solution suffers from the same problem these functions exhibit in\n// Python - their chained usages are difficult to read and write, as we frequently have to jump back\n// and forth to examine the arguments. This inconvenience was the primary motivation behind the pipe\n// operator ('|>').  The following code is fully equivalent to the one above but is easier to write,\n// read, and document:\nsquare2 = numbers\n    |> filter((x) -> x % 2 == 0) // filtering out odd numbers\n    |> map(square)               // squaring even numbers\n    |> filter((x) -> x < 50)     // filtering out squares larger than 50\n    |> reduce(max, 0)            // finding the largest square\n\nareSquaresTheSame = square1 == square2 // should be 'True'\n\n// Pipelines are inspired by the famous pipe operator present in all Unix shells. However, this is\n// not the first general-purpose language to feature them. Elixir and F# both have this operator\n// (that's where the syntax comes from). Even JavaScript has a stage 1 TC39 proposal to implement\n// it: https://tc39.es/proposal-pipeline-operator/#sec-intro.\n// The operator's semantics are most similar to F#. The pipeline 'a |> b |> c |> d' gets compiled to\n// 'd(c(b(a)))' and is type-checked accordingly.\n//\n// On a similar note, the language also features the functional composition operator ('.'), which is\n// essentially equivalent to functional composition in mathematics (\u2218). The composition 'a . b .\n// c . d' gets compiled to '(x) -> d(c(b(a(x))))' and is type-checked accordingly. Let's take a look\n// at how it works in practice:\nfunc f(x) = x * x\nfunc g(x) = x + 1\nfunc h(x) = 2 * x\n\nc1 = f . g . h         // calculates c1(x) = (2x + 1)^2\nc2 = g . h . f         // calculates c2(x) = 2x^2 + 1\nc3 = g . h . g . f . f // calculates c3(x) = 2(x^4 + 1) + 1\n\ntwentyFive = c1(2)\nnine       = c2(2)\nthirtyFive = c3(2)\n\n// You can compose anything you want, as long as the types match. The following function spells out\n// a single-digit number. Its type is 'Number -> [Char]'. Let's compose it with something.\nfunc readDigit(n) =\n    \"Zero\"  if n == 0 else\n    \"One\"   if n == 1 else\n    \"Two\"   if n == 2 else\n    \"Three\" if n == 3 else\n    \"Four\"  if n == 4 else\n    \"Five\"  if n == 5 else\n    \"Six\"   if n == 6 else\n    \"Seven\" if n == 7 else\n    \"Eight\" if n == 8 else\n    \"Nine\"  if n == 9 else\n    \"The number has more than one digit\"\n\nresultComp = (reverse . readDigit . length . readDigit . ((x) -> x % 10) . f)(4) // should be \"eerhT\"\n\n// Pipelines and compositions cover similar use cases - so similar one might wonder when to use\n// which. Pipelines are idiomatic to F#, while compositions are idiomatic to Haskell. The\n// recommendation is to use compositions when you want to focus on functions and what they do.\n// If you want the reader to focus on data and how it's transformed, pipelines are a better fit.\n//\n// Let's calculate 'resultComp' from above with a pipeline (again, newlines are optional):\nresultPipe = 4 |> f |> (x) -> x % 10 |> readDigit |> length |> readDigit |> reverse\n\n// So far, whenever we wanted to pass an operator to a higher-order function, we had to define a\n// trivial wrapper lambda. One example is summing all array members (let's pretend we didn't define\n// the function 'sum' for this exact purpose):\n\ns = reduce((x, y) -> x + y, 0, [1, 2, 3])\n\n// We essentially only wanted to pass the operator '+' to reduce as its first argument, but the\n// syntax forces us to define a meaningless anonymous function. The same applies to array products\n// and string array concatenation:\np = reduce((x, y) -> x * y, 1, [1, 2, 3])\nsentence = reduce((x, y) -> x ++ y, \"\", [\"This\", \" \", \"is\", \" \", \"a\", \" \", \"sentence.\"])\n\n//Again, all we want is to pass '*' and '++', respectively. However, doing so would result in a\n//syntax error. This is where operator referencing comes in.\n//\n// We can reference a binary operator by enclosing it in backticks. Doing so gives us an expression.\n// Let's use operator referencing to define alternatives to previously defined functions 'sum' and\n// 'product':\n\nsum2     = reduce(`+`, 0) // sticking with \"pointfree style\" (tacit programming)\nproduct2 = reduce(`*`, 1)\n\nzero = sum2([1, 2, 3]) - product2([1, 2, 3])\n\n// The function 'flatten' could also benefit from operator referencing:\nfunc flatten3(array) = reduce(`++`, [], array)\n\nsentence2 = flatten([\"This\", \" \", \"is\", \" \", \"a\", \" \", \"sentence.\"])\n\n// Again, operator references are full-fledged expressions. We can use them anywhere we want:\ndouble = `*`(2)\ncompose = `.`\n\nten1 = compose(double, sqrt)(25)\nten2 = `.`(double, sqrt)(25)\nten3 = (double . sqrt)(25)\n\n// Besides bare operator referencing, backticks also allow us to bind any expression to a binary\n// operator on either side. This feature opens the door for further simplification:\ndecimals = [2.5, 1.7, 4.3, 6.7, 3.6, 8.3, 2.3]\nlargerThanFive1 = filter((n) -> n > 5, decimals) // This can be simplified to...\nlargerThanFive2 = filter(`> 5`, decimals)        // ... this...\nlargerThanFive3 = filter(`5 <=`, decimals)       //  or this.\n\n// The operator referencing/binding syntax is valid for all binary operators, with no exceptions:\nfunc pipeToAll(value, functions) = map(`value |>`, functions)\n\nmarkoResults = pipeToAll(\"Marko\", [reverse, tail . tail, `++ \" Kutli\u0107\"`, readDigit . length])\n\n// We've now covered all of the language's currently available features. A few on them are still on\n// the todo list:\n// - Ad-hoc polymorphism (accomplished with type classes)\n// - Custom algebraic data types\n// - Pattern matching\n// - Named records\n// - User-defined type signatures\n//\n// Feel free to the test other samples and explore the language. Some of them have even been\n// mentioned throughout the text (Ctrl+f \"sample\"). Other interesting samples include:\n// - \"church\" - See how lambda calculus encodes various kinds of data\n// - \"prime\" - Finding prime numbers\n// - \"geometry\" - Examples related to geometry\n// - \"discrete\" - Examples related to discrete maths\n// - \"natives\" - Implementations of several native functions\n\n// Finally, here's an implementation of quicksort that uses most of the language's available\n// features:\nfunc sort(array) =\n    [] if isEmpty(array) else\n    let pivot = head(array);\n        rest  = tail(array);\n        smallerHalf = rest |> filter(`< pivot`) |> sort;\n        largerHalf  = rest |> filter(`>= pivot`) |> sort;\n    in [*smallerHalf, pivot, *largerHalf]\n\nsorted = sort(decimals)\n\n// Git repository: https://github.com/sodic/masters"
    },
    {
        "name": "lambda",
        "code": "// This sample demonstrates how we can use the fact that functions are first-class entities in\n// creative ways.\n\n// Two ways to define top-level functions. Prefer the first way, it's more clear and supports\n// recursion:\nfunc mul1(x, y) = x * y\nmul2 = (x, y) -> x * y\n\nfunc sub1(x, y) = x - y\nsub2 = (x, y) -> x - y\n\nfunc mod1(x, y) = x % y\nmod2 = (x, y) -> x % y\n\n// We can check whether functions are equivalent to each other, as well as to their respective\n// operator references.\nsamples = [(1, 3), (6, 8), (3, 5), (2, 3), (4, 9), (10, 9), (7, 2), (4, 7),]\n\nfunc all(predicate, array) = array \n    |> map(predicate) \n    |> reduce(`&&`, True)\n\nfunc areAllEqual(array) = tail(array) \n    |> all(`== head(array)`)\n\nareAllTrue = all(id)\n\n// Transforms a function of type a -> b -> c to a function of type (a, b) -> c. In other words, it\n// collects the first two arguments of a curried function into a tuple.\nuncurry = (f) -> (pair) -> f(first(pair), second(pair))\n\nfunctions =[\n    [mul1, mul2, `*`,],\n    [sub1, sub2, `-`,],\n    [mod1, mod2, `%`,],\n] |> (map . map)(uncurry)\n\nareFunctionsEquivalent =\n    let func applyToSample(sample) = functions\n        |> (map . map)(`sample |>`)\n    in samples\n        |> map(applyToSample)\n        |> (map . map)(areAllEqual)\n        |> map(areAllTrue)\n        |> areAllTrue\n\n\n// Let's find all samples where:\n// 1. The first number is even\n// 2. The second number is odd\n// 3. The first member is strictly lower than the second number\n// 4. The first number doubled is larger than the second number\n\nconditions = [\n    (x, y) -> x % 2 == 0,\n    (x, y) -> y % 2 == 1,\n    `<`,\n    (x, y) -> 2 * x > y,\n] |> map(uncurry)\n\n// This filter should leave only [(2, 3), (4, 7)]:\nfilteredSamples = samples\n    |> filter(\n        (sample) -> conditions |> map(`sample |>`) |> all(id)\n    )"
    },
    {
        "name": "natives",
        "code": "// This sample provides alternative implementations of several builtin functions ('map', 'filter',\n// 'reduce') and shows how to use them:\n\nfunc myMap(f, array) =\n    [] if isEmpty(array) else\n    let first = head(array) |> f;\n        rest = tail(array) |> myMap(f);\n    in [first, *rest]\n\nfunc myFilter(p, array) =\n    [] if isEmpty(array) else\n    let current = head(array);\n        others = tail(array) |> myFilter(p);\n    in [current, *others] if p(current) else\n        others\n\nfunc myReduce(f, acc, array) =\n    acc if isEmpty(array) else\n    myReduce(f, f(acc, head(array)), tail(array))\n\nfunc myReduce0(f, array) =\n    myReduce(f, head(array), tail(array))\n\nfunc step(thresh, x) = 0 if x < thresh else 1\nfunc min(x, y) = x if x < y else y\n\nnumbers = [1.2, 2.5, 3.4, 4.3, 2.1, 1.8, 4.7]\n\n// Let's compare builtins to user-defined alternatives\nsum = reduce(`+`, 0, numbers)\nmySum = myReduce(`+`, 0, numbers)\nisSumOk = mySum == sum\n\nproduct = reduce0(`*`, numbers)\nmyProduct = myReduce0(`*`, numbers)\nisProductOk = product == myProduct\n\nlowestGreaterThan3 = numbers\n    |> myFilter(`> 3`)\n    |> myReduce0(min)\n\n// This should be \"0111001\"\ndigitalSignal = numbers\n    |> myMap(step(2.5))\n    |> join(\"\")"
    },
    {
        "name": "power",
        "code": "// A simple implementation of 'pow'.\n\nfunc raiseToPower(number, power) =\n    1 if power <= 0 else\n    number * raiseToPower(number, power - 1)\n\nfunc flipArgs(f, x, y) = f(y, x)\n\nraise3To = raiseToPower(3)\nraiseTo3 = flipArgs(raiseToPower)(3)\n\nthreeSquared = raise3To(2)\ntwoToTheThird = raiseTo3(2)\n\nfunc raiseToPowerFast(n, p) = \n    1 if p == 0 else \n    raiseToPowerFast(n * n, floor(p / 2)) \n        * (1 if p % 2 == 0 else n)\n\nrp = raiseToPowerFast(1.000001, 9999999)\n\nshouldBeTrue = 8 == raiseToPowerFast(2, 3)"
    },
    {
        "name": "prime",
        "code": "// An algorithm that determines whether a number is prime:\n\nfunc testSequence(test, isDone, next, curr) =\n    True if test(curr) else\n    False if isDone(curr) else\n        testSequence(test, isDone, next, next(curr))\n\nfunc anyInRange(test, start, end, step) =\n    testSequence(test, `> end`, `+ step`, start)\n\nfunc isPrime(n) =\n    False if n == 1 else\n    True if n == 2 else\n    False if n % 2 == 0 else\n    let func dividesN(k) = n % k == 0\n    in !anyInRange(dividesN, 3, sqrt(n), 2)\n\nis1Prime = isPrime(1)\nis2Prime = isPrime(2)\nis4Prime = isPrime(4)\nis7Prime = isPrime(7)\nis16Prime = isPrime(16)\nis27Prime = isPrime(27)\nis63Prime = isPrime(63)\nis97Prime = isPrime(97)\nis117Prime = isPrime(117)\nis269Prime = isPrime(269)"
    },
    {
        "name": "recursive-apply",
        "code": "// A simple example of recursive function application:\n\nfunc applyNTimes(n, f, arg) =\n    arg if n <= 0 else\n    let\n        x = applyNTimes(n - 1, f, arg)\n    in f(x)\n\nfunc multiply(x, y) = x * y\nfunc square(x) = multiply(x, x)\n\napply5Times = applyNTimes(5)\npower32 = apply5Times(square)\n\n// 2 ^ 32\nresult = power32(2)"
    },
    {
        "name": "speed",
        "code": "// This is only a speed test. The code below used to be extremely slow to parse (~13s)\nnested = [\n    [[(2, \"One\")], [(2, \"Two\")], [(3, \"Three\")]],\n    [[(4, \"Four\")], [(5, \"Five\")], [(6, \"Six\")]],\n]"
    },
    {
        "name": "tuples",
        "code": "// This sample demonstrates how to work with tuples.\n\nluka = (\"Luka\", 23)\nmarko = (\"Marko\", 25)\n\nfunc isAdult(person) = second(person) > 18\n\nfunc flip(pair) = (second(pair), first(pair))\n\nlukaReport =\n    \"Luka is old enough to drive\"\n        if isAdult(luka) else\n    \"Luka is not old enough to drive\"\n\ntotalAge = first(flip(luka)) + second(marko)"
    }
]
